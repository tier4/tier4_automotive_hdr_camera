/*
* Copyright (c) 2021, Ability CORPORATION.  All rights reserved.
* Based on Copyright (c) 2018, NVIDIA CORPORATION.  All rights reserved.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version. 
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License 
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/ {

  tegra-capture-vi {
    num-channels = <8>;
    ports {
      #address-cells = <1>;
      #size-cells = <0>;
      port@0 {
        reg = <0>;
        status = "okay";
        isx021_vi_in0: endpoint {
          /*the port binding to VI and CSI*/
          status = "okay";
          vc-id = <0>; 							/*VI and CSI channel-id,must match the gmsl-link device node’s vc-id” property.*/
          port-index = <0>;						/*use VI stream 0*/
          bus-width = <2>;						/*The bus-width property specifies the number of CSI lanes used.*/
          remote-endpoint = <&isx021_csi_out0>;
        };
      };
      port@1 {
        reg = <1>;
        status = "okay";
        isx021_vi_in1: endpoint {
          status = "okay";
          vc-id = <1>;
          port-index = <0>;
          bus-width = <2>;
          remote-endpoint = <&isx021_csi_out1>;
        };
      };
      port@2 {
        reg = <2>;
        status = "okay";
        isx021_vi_in2: endpoint {
          status = "okay";
          vc-id = <0>;
          port-index = <2>;
          bus-width = <2>;
          remote-endpoint = <&isx021_csi_out2>;
        };
      };
      port@3 {
        reg = <3>;
        status = "okay";
        isx021_vi_in3: endpoint {
          status = "okay";
          vc-id = <1>;
          port-index = <2>;
          bus-width = <2>;
          remote-endpoint = <&isx021_csi_out3>;
        };
      };
      port@4 {
        reg = <4>;
        status = "okay";
        isx021_vi_in4: endpoint {
          status = "okay";
          vc-id = <0>;
          port-index = <4>;
          bus-width = <2>;
          remote-endpoint = <&isx021_csi_out4>;
        };
      };
      port@5 {
        reg = <5>;
        status = "okay";
        isx021_vi_in5: endpoint {
          status = "okay";
          vc-id = <1>;
          port-index = <4>;
          bus-width = <2>;
          remote-endpoint = <&isx021_csi_out5>;
        };
      };
      port@6 {
        reg = <6>;
        status = "okay";
        isx021_vi_in6: endpoint {
          status = "okay";
          vc-id = <0>;
          port-index = <5>;
          bus-width = <2>;
          remote-endpoint = <&isx021_csi_out6>;
        };
      };
      port@7 {
        reg = <7>;
        status = "okay";
        isx021_vi_in7: endpoint {
          status = "okay";
          vc-id = <1>;
          port-index = <5>;
          bus-width = <2>;
          remote-endpoint = <&isx021_csi_out7>;
        };
      };
    };
  };

  host1x@13e00000 {
    nvcsi@15a00000 {
      num-channels = <8>;
      #address-cells = <1>;
      #size-cells = <0>;
      channel@0 {
        reg = <0>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in0: endpoint@0 {
              status = "okay";
              port-index = <0>;						/*CSI port A(0) */
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out0>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out0: endpoint@1 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in0>;
            };
          };
        };
      };
      channel@1{
        reg = <1>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in1: endpoint@2 {
              status = "okay";
              port-index = <0>;
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out1>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out1: endpoint@3 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in1>;
            };
          };
        };
      };
      channel@2 {
        reg = <2>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in2: endpoint@4 {
              status = "okay";
              port-index = <2>;
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out2>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out2: endpoint@5 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in2>;
            };
          };
        };
      };
      channel@3{
        reg = <3>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in3: endpoint@6 {
              status = "okay";
              port-index = <2>;
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out3>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out3: endpoint@7 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in3>;
            };
          };
        };
      };
      channel@4{
        reg = <4>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in4: endpoint@8 {
              status = "okay";
              port-index = <4>;
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out4>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out4: endpoint@9 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in4>;
            };
          };
        };
      };
      channel@5{
        reg = <5>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in5: endpoint@10 {
              status = "okay";
              port-index = <4>;
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out5>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out5: endpoint@11 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in5>;
            };
          };
        };
      };
      channel@6{
        reg = <6>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in6: endpoint@10 {
              status = "okay";
              port-index = <6>;
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out6>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out6: endpoint@11 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in6>;
            };
          };
        };
      };
      channel@7{
        reg = <7>;
        status = "okay";
        ports {
          #address-cells = <1>;
          #size-cells = <0>;
          port@0 {
            reg = <0>;
            status = "okay";
            isx021_csi_in7: endpoint@14 {
              status = "okay";
              port-index = <6>;
              bus-width = <2>;
              remote-endpoint = <&isx021_isx021_out7>;
            };
          };
          port@1 {
            reg = <1>;
            status = "okay";
            isx021_csi_out7: endpoint@15 {
              status = "okay";
              remote-endpoint = <&isx021_vi_in7>;
            };
          };
        };
      };
    };
  };

  i2c@3180000 {
    tca9546@70 {
      status = "okay";
      i2c@0 {
        isx021_a@1b {
          compatible = "nvidia,tier4_isx021";
          reg = <0x1b>;
          status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <0>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";

          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_a";
            vc_id = "0";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";

            pix_clk_hz = "74250000";
            serdes_pix_clk_hz =   "180000000";

            gain_factor = "10";
            min_gain_val = "0"; 						/* dB */
            max_gain_val = "300"; 						/* dB */
            step_gain_val = "3"; 						/* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; 						/* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";					/* us */
            embedded_metadata_height = "0";
          };
          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out0: endpoint {
                vc-id = <0>;
                port-index = <0>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in0>;
              };
            };
          };
          gmsl-link {
            src-csi-port = "b";		/* Port at which sensor is connected to its serializer device. */
            dst-csi-port = "a";		/* Destination CSI port on the Jetson side, connected at deserializer. */
            serdes-csi-link = "a";	/* GMSL link sensor/serializer connected */
            csi-mode = "1x4";		/*  to sensor CSI mode. */
            st-vc = <0>;			/* Sensor source default VC ID: 0 unless overridden by sensor. */
            vc-id = <0>;			/* Destination VC ID, assigned to sensor stream by deserializer. */
            num-lanes = <2>;		/* Number of CSI lanes used. */
            //	streams = "ued-u1","yuv8"; /* Types of streams sensor is streaming. */
            streams = "ued-u1", "yuv8"; /* Types of streams sensor is streaming. */
          };
        };

        isx021_b@1c {
          compatible = "nvidia,tier4_isx021";
          reg = <0x1c>;
          status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <0>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";

          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_a";
            vc_id = "1";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";

            pix_clk_hz = "74250000";
            serdes_pix_clk_hz =   "180000000";

            gain_factor = "10";
            min_gain_val = "0"; 							/* dB */
            max_gain_val = "300"; 							/* dB */
            step_gain_val = "3"; 							/* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; 							/* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";						/* us */
            embedded_metadata_height = "0";
          };

          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out1: endpoint {
                vc-id = <1>;
                port-index = <0>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in1>;
              };
            };
          };
          gmsl-link {
            src-csi-port = "b";
            dst-csi-port = "a";
            serdes-csi-link = "b";
            csi-mode = "1x4";
            st-vc = <0>;
            vc-id = <1>;
            num-lanes = <2>;
            streams = "ued-u1","yuv8";
          };
        };
      };
      i2c@1 {
        isx021_c@1b {
          compatible = "nvidia,tier4_isx021";

          reg = <0x1b>;
          status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <1>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";

          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_c";
            vc_id = "0";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";
            pix_clk_hz = "74250000";
            serdes_pix_clk_hz =   "180000000";

            gain_factor = "10";
            min_gain_val = "0"; /* dB */
            max_gain_val = "300"; /* dB */
            step_gain_val = "3"; /* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; /* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";/* us */
            embedded_metadata_height = "0";
          };

          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out2: endpoint {
                vc-id = <0>;
                port-index = <2>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in2>;
              };
            };
          };

          gmsl-link {
            src-csi-port = "b";				/* Port at which sensor  is connected to its serializer device. */
            dst-csi-port = "a";				/* Destination CSI port on the Jetson side, connected at deserializer. */
            serdes-csi-link = "a";			/* GMSL link sensor/serializer connected */
            csi-mode = "1x4";				/*  to sensor CSI mode. */
            st-vc = <0>;					/* Sensor source default VC ID: 0 unless overridden by sensor. */
            vc-id = <0>;					/* Destination VC ID, assigned to sensor stream by deserializer. */
            num-lanes = <2>;				/* Number of CSI lanes used. */
            streams = "ued-u1","yuv8"; 				/* Types of streams sensor is streaming. */
          };
        };

        isx021_d@1c {
          compatible = "nvidia,tier4_isx021";
          reg = <0x1c>;
        status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <1>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";

          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_c";
            vc_id = "1";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";
            pix_clk_hz = "74250000";
            serdes_pix_clk_hz =   "180000000";

            gain_factor = "10";
            min_gain_val = "0"; /* dB */
            max_gain_val = "300"; /* dB */
            step_gain_val = "3"; /* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; /* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";/* us */
            embedded_metadata_height = "0";
          };

          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out3: endpoint {
                vc-id = <1>;
                port-index = <2>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in3>;
              };
            };
          };
          gmsl-link {
            src-csi-port = "b";
            dst-csi-port = "a";
            serdes-csi-link = "b";
            csi-mode = "1x4";
            st-vc = <0>;
            vc-id = <1>;
            num-lanes = <2>;
            streams = "ued-u1","yuv8";
          };
        };
      };

      i2c@2 {
        isx021_e@1b {
          compatible = "nvidia,tier4_isx021";

          reg = <0x1b>;
        status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <2>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";

          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_e";
            vc_id = "0";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";
            pix_clk_hz = "74250000";
            serdes_pix_clk_hz =   "180000000";

            gain_factor = "10";
            min_gain_val = "0"; /* dB */
            max_gain_val = "300"; /* dB */
            step_gain_val = "3"; /* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; /* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";/* us */
            embedded_metadata_height = "0";
          };

          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out4: endpoint {
                vc-id = <0>;
                port-index = <4>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in4>;
              };
            };
          };
          gmsl-link {
            src-csi-port = "b";
            dst-csi-port = "a";
            serdes-csi-link = "a";
            csi-mode = "1x4";
            st-vc = <0>;
            vc-id = <0>;
            num-lanes = <2>;
            streams = "ued-u1","yuv8";
          };
        };

        isx021_f@1c {
          compatible = "nvidia,tier4_isx021";

          reg = <0x1c>;
        status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <2>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";


          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_e";
            vc_id = "1";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";
            pix_clk_hz = "94500000";
            serdes_pix_clk_hz = "833333333";

            gain_factor = "10";
            min_gain_val = "0"; /* dB */
            max_gain_val = "300"; /* dB */
            step_gain_val = "3"; /* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; /* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";/* us */
            embedded_metadata_height = "0";
          };

          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out5: endpoint {
                vc-id = <1>;
                port-index = <4>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in5>;
              };
            };
          };
          gmsl-link {
            src-csi-port = "b";
            dst-csi-port = "a";
            serdes-csi-link = "b";
            csi-mode = "1x4";
            st-vc = <0>;
            vc-id = <1>;
            num-lanes = <2>;
            streams = "ued-u1","yuv8";
          };
        };
      };

      i2c@3 {
        isx021_g@1b {
          compatible = "nvidia,tier4_isx021";
          reg = <0x1b>;
        status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <3>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";

          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_g";
            vc_id = "0";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";
            pix_clk_hz = "74250000";
            serdes_pix_clk_hz =   "180000000";

            gain_factor = "10";
            min_gain_val = "0"; /* dB */
            max_gain_val = "300"; /* dB */
            step_gain_val = "3"; /* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; /* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";/* us */
            embedded_metadata_height = "0";
          };

          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out6: endpoint {
                vc-id = <0>;
                port-index = <5>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in6>;
              };
            };
          };
          gmsl-link {
            src-csi-port = "b";
            dst-csi-port = "a";
            serdes-csi-link = "a";
            csi-mode = "1x4";
            st-vc = <0>;
            vc-id = <0>;
            num-lanes = <2>;
            streams = "ued-u1","yuv8";
          };
        };
        isx021_h@1c {
          compatible = "nvidia,tier4_isx021";

          reg = <0x1c>;
        status = "okay";

          /* Physical dimensions of sensor */
          physical_w = "15.0";
          physical_h = "12.5";
          reg_mux = <3>;
          sensor_model ="isx021";

          fsync-mode = "false";

          distortion-correction = "false";

          auto-exposure = "true";

          /* Defines number of frames to be dropped by driver internally after applying */
          /* sensor crop settings. Some sensors send corrupt frames after applying */
          /* crop co-ordinates */
          post_crop_frame_drop = "0";

          /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
          use_decibel_gain = "true";

          /* enable CID_SENSOR_MODE_ID for sensor modes selection */
          use_sensor_mode_id = "true";

          mode0 {
            /*mode ISX021_MODE_1920X1280_CROP_30FPS*/
            mclk_khz = "24000";
            num_lanes = "2";
            tegra_sinterface = "serial_g";
            vc_id = "1";
            discontinuous_clk = "no";
            dpcm_enable = "false";
            cil_settletime = "0";
            dynamic_pixel_bit_depth = "16";
            csi_pixel_bit_depth = "16";
            mode_type = "yuv";
            pixel_phase = "uyvy";

            active_w = "1920";
            active_h = "1280";
            readout_orientation = "0";
            line_length = "2250";
            inherent_gain = "1";
            pix_clk_hz = "94500000";
            serdes_pix_clk_hz =   "180000000";

            gain_factor = "10";
            min_gain_val = "0"; /* dB */
            max_gain_val = "300"; /* dB */
            step_gain_val = "3"; /* 0.3 */
            default_gain = "0";
            min_hdr_ratio = "1";
            max_hdr_ratio = "1";
            framerate_factor = "1000000";
            min_framerate = "30000000";
            max_framerate = "30000000";
            step_framerate = "1";
            default_framerate = "30000000";
            exposure_factor = "1000000";
            min_exp_time = "24"; /* us 1 line */
            max_exp_time = "33333";
            step_exp_time = "1";
            default_exp_time = "33333";/* us */
            embedded_metadata_height = "0";
          };

          ports {
            #address-cells = <1>;
            #size-cells = <0>;
            port@0 {
              reg = <0>;
              isx021_isx021_out7: endpoint {
                vc-id = <0>;
                port-index = <5>;
                bus-width = <2>;
                remote-endpoint = <&isx021_csi_in7>;
              };
            };
          };
          gmsl-link {
            src-csi-port = "b";
            dst-csi-port = "a";
            serdes-csi-link = "b";
            csi-mode = "1x4";
            st-vc = <0>;
            vc-id = <1>;
            num-lanes = <2>;
            streams = "ued-u1","yuv8";
          };
        };
      };
    };
  };

  tegra-camera-platform {
    compatible = "nvidia, tegra-camera-platform";
    num_csi_lanes = <8>;
    max_lane_speed = <4000000>;
    min_bits_per_pixel = <10>;
    vi_peak_byte_per_pixel = <2>;
    vi_bw_margin_pct = <25>;
    isp_peak_byte_per_pixel = <5>;
    isp_bw_margin_pct = <25>;
    modules {
      module0 {
        badge = "isx021_rear";
        position = "rear";
        orientation = "1";
        status = "okay";
        drivernode0 {
          /* Declare PCL support driver (classically known as guid)  */
          status = "okay";
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 30-001b";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@0/isx021_a@1b";
        };
      };
      module1 {
        badge = "isx021_front";
        position = "front";
        orientation = "1";
        drivernode0 {
          status = "okay";
          /* Declare PCL support driver (classically known as guid)  */
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 30-001c";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@0/isx021_b@1c";
        };
      };
      module2 {
        badge = "isx021_topright";
        position = "topright";
        orientation = "1";
        status = "okay";
        drivernode0 {
          /* Declare PCL support driver (classically known as guid)  */
        status = "okay";
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 31-001b";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@1/isx021_c@1b";
        };
      };
      module3 {
        badge = "isx021_bottomright";
        position = "bottomright";
        orientation = "1";
        status = "okay";
        drivernode0 {
          /* Declare PCL support driver (classically known as guid)  */
        status = "okay";
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 31-001c";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@1/isx021_d@1c";
        };
      };
      module4 {
        badge = "isx021_topleft";
        position = "topleft";
        orientation = "1";
        status = "okay";
        drivernode0 {
          /* Declare PCL support driver (classically known as guid)  */
        status = "okay";
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 32-001b";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@2/isx021_e@1b";
        };
      };
      module5 {
        badge = "isx021_centerright";
        position = "cnterright";
        orientation = "1";
        status = "okay";
        drivernode0 {
          /* Declare PCL support driver (classically known as guid)  */
        status = "okay";
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 32-001c";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@2/isx021_f@1c";
        };
      };
      module6 {
        badge = "isx021_cneterleft";
        position = "centerleft";
        orientation = "1";
        status = "okay";
        drivernode0 {
        status = "okay";
          /* Declare PCL support driver (classically known as guid)  */
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 33-001b";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@3/isx021_g@1b";
        };
      };
      module7 {
        badge = "isx021_bottomleft";
        position = "bottomleft";
        orientation = "1";
        status = "okay";
        drivernode0 {
          /* Declare PCL support driver (classically known as guid)  */
        status = "okay";
          pcl_id = "v4l2_sensor";
          /* Driver v4l2 device name */
          devname = "isx021 33-001c";
          /* Declare the device-tree hierarchy to driver instance */
          proc-device-tree = "/proc/device-tree/i2c@3180000/tca9546@70/i2c@3/isx021_h@1c";
        };
      };
    };
  };
};
